#!/bin/sh
#
# On Windows, use an embeddable Python release from python.org.
# On Unixes, use the system's Python inside a virtualenv.
# Installs requirements from requirements.txt when changed.
# TODO: Add a requirements.freeze.txt lockfile.
#
# A warning about Python versions:
# - Not all versions get Wndows embedded .zip releases; check https://www.python.org/ftp/python/.
# - Manylinux AppImages are used for Linux, so keep in mind what glibc versions are still used on distros. Steamrt/scout only supports up to Manylinux 2010.
# - MacOS Catalina 10.15.7 has 3.8.2.
#
set -eu

Bootstrap=$(dirname "$0")
. "$Bootstrap/_common.sh"

# Convenience variables
Sdk="$(dirname "$Bootstrap")"

if test "$OS" != "Windows"; then
	if test "$OS" = "Linux"; then
		# Linux: use Manylinux AppImages
		PythonExe="$Cache/python-$PYTHON_VERSION.$PYTHON_LINUX_PATCH-$PYTHON_MANYLINUX"
		if ! test -f "$PythonExe"; then
			TmpExe=$(temp_download_and_verify PYTHON_VERSION Linux)
			chmod +x "$TmpExe"
			mv "$TmpExe" "$PythonExe"
		fi

		# Use AppImage's workaround if we would be running it under Docker.
		if test "$OS" = Linux && ! command -v fusermount >/dev/null 2>&1; then
			ExtractedDir="$Cache/python-$PYTHON_VERSION.$PYTHON_LINUX_PATCH-$PYTHON_MANYLINUX.extracted"
			if ! test -d "$ExtractedDir"; then
				PythonExe=$(realpath "$PythonExe")
				TempDir=$(temp_directory)
				(cd "$TempDir" && "$PythonExe" --appimage-extract >/dev/null)
				mv "$TempDir/squashfs-root" "$ExtractedDir"
			fi
			PythonExe="$ExtractedDir/AppRun"
		fi
	else
		# Mac, presumably, so cross our fingers and use the old logic.
		if command -v python3 >/dev/null 2>&1; then
			PythonExe=python3
		elif command -v python >/dev/null 2>&1; then
			PythonExe=python
		elif command -v py >/dev/null 2>&1; then
			PythonExe="py -3"
		else
			echo >&2
			echo "Please install Python $PYTHON_VERSION or newer from https://www.python.org/downloads/ or using your system's package manager." >&2
			echo >&2
			exit 1
		fi
	fi

	# Create a venv and activate it
	PythonDir="$Cache/python-venv-$PYTHON_VERSION"
	if ! test -d "$PythonDir"; then
		python_venv() {
			TmpPythonDir=$(mktemp -d "$PythonDir.tmpXXXXXXXX")
			"$PythonExe" -m venv "$TmpPythonDir"
			mv "$TmpPythonDir" "$PythonDir"
		}
		one_at_a_time python_venv
	fi
	PythonExe="$PythonDir/bin/python"
else
	# Windows bootstrap.

	# Strip the "App Execution Aliases" from $PATH. Even if the user installed
	# Python using the Windows Store on purpose, these aliases always generate
	# "Permission denied" errors when sh.exe tries to invoke them.
	PATH=$(echo "$PATH" | tr ":" "\n" | grep -v "AppData/Local/Microsoft/WindowsApps" | tr "\n" ":")

	PythonArch="amd64"
	PythonDir="$Cache/python-$PYTHON_VERSION.$PYTHON_WINDOWS_PATCH-embed-$PythonArch"
	PythonExe="$PythonDir/python.exe"

	# Download and unzip a portable version of Python
	if ! test -d "$PythonDir"; then
		python_unzip() {
			TmpPythonDir=$(temp_unzip "$(temp_download_and_verify PYTHON_VERSION Windows)")
			# Copy a ._pth file without "import site" commented, so pip will work.
			cp "$Bootstrap/python36._pth" -t "$TmpPythonDir"
			# Install pip.
			GetPip=$(temp_file)
			download_file "https://bootstrap.pypa.io/pip/3.6/get-pip.py" "$GetPip"
			"$TmpPythonDir/python.exe" "$GetPip" --no-warn-script-location
			# Commit the extracted Python directory.
			mv "$TmpPythonDir" "$PythonDir"
		}
		one_at_a_time python_unzip
	fi
fi

# Verify version and query the path separator
PathSep=$("$PythonExe" - "$PYTHON_VERSION" <<'EOF'
import sys, os
wanted = [int(x) for x in sys.argv[1].split('.')]
if sys.version_info.major != wanted[0] or sys.version_info.minor < wanted[1]:
	print("Error: Python ", sys.argv[1], " or later is required, but you have:\n", sys.version, sep="", file=sys.stderr)
	exit(1)
print(os.pathsep)
EOF
)

# Use pip to install our requirements
Requirements="requirements.txt"
if ! test -f "$PythonDir/$Requirements" || test "$(sha256sum < "$Sdk/$Requirements")" != "$(sha256sum < "$PythonDir/$Requirements")"; then
	python_pip() {
		"$PythonExe" -m pip install -U wheel >&2
		"$PythonExe" -m pip install -U pip >&2
		"$PythonExe" -m pip install -r "$Sdk/$Requirements" >&2
		cp "$Sdk/$Requirements" "$PythonDir/$Requirements"
		echo "---" >&2
	}
	one_at_a_time python_pip
fi

# Invoke python with all command-line arguments
export PYTHONPATH="$Sdk$PathSep${PYTHONPATH:-}"
exec "$PythonExe" -u "$@"
